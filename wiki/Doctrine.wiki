= Result =
这里讨论一些 搜索(Select语句)后返回的结果。


$res = $q->fetchOne(); 和 $res = $q->execute(); 返回的都是对象。
$res->id 也是对象。


{{{
// 当没有结果时
$q->fetchOne(); // 返回 空NULL。 
$q->execute();  // 返回一个对象。不能能用 if 直接判断


## 在查询一个的情况下 例如 find, findOne, fetchOne
## 如果不存在 则返回 false
$member = Doctrine::getTable('Member')->find(1);
if($member) {
	//do 
}
}}}

= Search = 

{{{
## return one
Doctrine::getTable('Member')->findOneByKeyword($key); 

## return list
Doctrine::getTable('Member')->findByKeyword($key);

## find by id
Doctrine::getTable('Member')->find(1); // id 为 1 的会员。

## find all
Doctrine::getTable('Member')->findAll();

## 于codeinteger 整合 此部分于CI2.0舍去 
//调用 $CI->uri->segment($u);
Doctrine::getTable('Member')->getBySegment(3); # /member/info/4 id为4的会员

//调用 $CI->uri->rsegment($u);
Doctrine::getTable('News')->getByRSegment(3);# 使用 URI Routing 情况下读取字段 /news-12.html
}}}

{{{
## query
$q = Doctrine_Query::create()
		->from('RankGroup')
		->where("member_id='{$member->id}'")
		->orderBy('id');
$q->fetchOne(); // *return one or null*
$q->execute();
$q->execute()->toArray(); //return array
$q->getSqlQuery();// return SQL
}}}

=== 直接使用SQL ===
为了性能方面的优化，可以直接使用SQL

{{{
//Note: If you want to select a specific connection first, then call:
//Doctrine_Manager::getInstance()->setCurrentConnection(’your_connection_name_1′);
// Get Doctrine_Connection object

$con = Doctrine_Manager::getInstance()->connection();

// SQL 
$sql = "select * from product";

// Execute SQL query, receive Doctrine_Connection_Statement
$st = $con->execute($sql);

// Fetch query result
$result = $st->fetchAll();
}}}

=== Doctrine_RawSql  ===
官方手册提供的，执行Native SQL的方法。其他的暂不知。持保留态度。

{{{
$conn = Doctrine_Manager::connection();
$q = new Doctrine_RawSql($conn);

$q->select('{u.*}')
  ->from('user u')
  ->addComponent('u', 'User');

$users = $q->execute();
print_r($users->toArray());
}}}

= add, edit, delete =

{{{
$member = Doctrine::getTable('Member')->find(1);

$member->save(); // add & edit
$member->delete();//delete

//sql delete
$q = Doctrine_Query::create()
		->delete('Member')
		->where('id = ?', $id);
$q->execute();
}}}

= 表的关联 =

 * 当不使用时，不会执行查询语句，并调用。当使用时 才会被调用
 * 使用Left Join 语句是会自动调用

一些经验：　使用起来，感觉单独使用hasOne可以很方便，hasMany 在单独使用的时候感觉比较别扭。 不过在leftJoin的情况下除外。

{{{
# $Rank->Member , 不调用时不会查询， 当调用时才会自动查询。
$Rank->Member->usename;

# left join 时调用 
$q = Doctrine_Query::create()
      ->from('Rank r')
      ->leftJoin('r.Member m');
}}}

{{{
$this->hasOne('Member', array(
		'local' => 'member_id',
		'foreign' => 'id'
	)
);

$this->hasMany('Email', array(
		'local' => 'id',
		'foreign' => 'user_id'
	)
);
}}}

== 多對多 ==

local 是 本類id 對應 PdoVirtualHostM表中的字段

foreign 是 對應表的id 對應 PdoVirtualHostM表中的字段
{{{
// 必須兩個類都要配置正確
$this->hasMany('PdoVirtualHostServer as Servers', array(
		'refClass' => 'PdoVirtualHostM',
		'local' => 'virtual_host_id',
		'foreign' => 'virtual_host_server_id'
	)
);
}}}

調用
{{{
$m	= Model_VirtualHost::getTable()->find($i);

$m->Servers[0] = $virtualHostServer;
$m->save();
}}}

清除關聯
{{{
$member->unlink('VirtualHostServers');
$member->save();
}}}

= Cache =
ORM确实方便开发，但是当使用过多的 使用复杂的数据关系，以及调用过多的查询相关，会明显慢下来。

 * 数据使用一个Sql语句查询。不在依赖定义的关系。
  * 由于使用leftjoin()时会会自动加载定义的关系， 所以可以把一些关系直接使用leftjoin()写出来，哪怕没有判断条件。
 * 使用Cache。
  * 注意cache的時間，這個cache只有过期后才会更新数据。
  
= 指定不同的數據庫 =

{{{
Doctrine_Manager::getInstance()->bindComponent('User', 'main')
User 使用 mian 連接
}}}

{{{
// 定义
$cacheConn = Doctrine_Manager::connection(new PDO('sqlite:'.VARPATH.'/cache.sqlite'));
$cacheDriver = new Doctrine_Cache_Db(array('connection' => $cacheConn, 'tableName' => 'cache'));
//$cacheDriver->createTable();//第一次使用时执行。

Doctrine_Manager::getInstance()->setAttribute(Doctrine_Core::ATTR_RESULT_CACHE, $cacheDriver);
Doctrine_Manager::getInstance()->setAttribute(Doctrine::ATTR_RESULT_CACHE_LIFESPAN, 1800);

// 使用
$q = Doctrine_Query::create()
	->from('RankLog')
	->where("rank_id={$this->id}")
	->orderBy('rank_order desc')
	->limit(2)
	->useResultCache(true)
	->setResultCacheLifeSpan(3600);
}}}